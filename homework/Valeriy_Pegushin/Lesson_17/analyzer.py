# Импорт модуля для работы с аргументами командной строки
import argparse
# Импорт модуля для работы с операционной системой
import os
# Импорт модуля системных функций
import sys
# Импорт Path из модуля pathlib для удобной работы с путями
from pathlib import Path


# Определение функции для поиска текста в файле
def search_in_file(file_path, search_text, context_words=5):
    """
    Ищет текст в файле и возвращает результаты с контекстом.

    Args:
        file_path (Path): Путь к файлу
        search_text (str): Текст для поиска
        context_words (int): Количество слов контекста с каждой стороны

    Returns:
        list: Список результатов в формате (номер_строки, строка_с_контекстом)
    """
    # Создание пустого списка для хранения результатов
    results = []
    # Начало блока обработки исключений
    try:
        # Открытие файла для чтения с кодировкой UTF-8
        with open(file_path, 'r', encoding='utf-8') as file:
            # Чтение файла построчно с нумерацией строк начиная с 1
            for line_num, line in enumerate(file, 1):
                # Проверка наличия искомого текста в текущей строке
                if search_text in line:
                    # Разбивка строки на отдельные слова
                    words = line.split()
                    # Инициализация переменной для хранения индекса найденного слова
                    found_index = -1

                    # Поиск конкретного слова, содержащего искомый текст
                    for i, word in enumerate(words):
                        # Проверка наличия искомого текста в текущем слове
                        if search_text in word:
                            # Сохранение индекса найденного слова
                            found_index = i
                            # Прерывание цикла после первого найденного совпадения
                            break

                    # Проверка, было ли найдено совпадение
                    if found_index != -1:
                        # Вычисление начального индекса для контекста
                        start = max(0, found_index - context_words)
                        # Вычисление конечного индекса для контекста
                        end = min(len(words), found_index + context_words + 1)

                        # Формирование строки с контекстом из среза слов
                        context = ' '.join(words[start:end])
                        # Добавление результата в список
                        results.append((line_num, context))

    # Обработка исключения неправильной кодировки файла
    except UnicodeDecodeError:
        # Возврат пустого списка для бинарных файлов
        return []
    # Обработка всех остальных исключений
    except Exception as e:
        # Вывод сообщения об ошибке в стандартный поток ошибок
        print(f"Ошибка при чтении файла {file_path}: {e}", file=sys.stderr)
        # Возврат пустого списка при ошибке
        return []

    # Возврат списка с результатами поиска
    return results


# Определение основной функции программы
def main():
    # Создание парсера аргументов командной строки
    parser = argparse.ArgumentParser(description="Поиск текста в лог-файлах")
    # Добавление обязательного аргумента - пути к директории
    parser.add_argument("directory", help="Полный путь к папке с логами")
    # Добавление обязательного именованного аргумента --text для текста поиска
    parser.add_argument("--text", required=True, help="Текст для поиска")
    # Добавление необязательного именованного аргумента --date для фильтрации по дате
    parser.add_argument("-d", "--date", help="Дата для поиска (необязательно)")

    # Разбор аргументов командной строки
    args = parser.parse_args()

    # Проверка существования и доступности указанной директории
    if not os.path.isdir(args.directory):
        # Вывод сообщения об ошибке если директория не существует
        print(f"Ошибка: Директория '{args.directory}' не существует или недоступна", file=sys.stderr)
        # Завершение программы с кодом ошибки 1
        sys.exit(1)

    # Преобразование строки пути в объект Path для удобной работы
    directory_path = Path(args.directory)
    # Сохранение искомого текста в переменную
    search_text = args.text
    # Флаг для отслеживания, были ли найдены совпадения
    found_any = False

    # Вывод информационного сообщения о начале поиска
    print(f"Поиск текста '{search_text}' в директории: {directory_path}")
    # Вывод разделительной линии
    print("-" * 80)

    # Итерация по всем элементам в указанной директории
    for file_path in directory_path.iterdir():
        # Проверка, является ли текущий элемент файлом
        if file_path.is_file():
            # Проверка, указан ли аргумент даты И дата отсутствует в имени файла
            if args.date and args.date not in file_path.name:
                # Пропуск файла если он не соответствует фильтру даты
                continue

            # Вызов функции поиска в текущем файле
            results = search_in_file(file_path, search_text)

            # Проверка, найдены ли совпадения в файле
            if results:
                # Установка флага что найдены совпадения
                found_any = True
                # Вывод имени файла где найдены совпадения
                print(f"Файл: {file_path.name}")
                # Вывод количества найденных совпадений в файле
                print(f"Найдено совпадений: {len(results)}")

                # Итерация по всем найденным совпадениям в файле
                for line_num, context in results:
                    # Вывод номера строки и контекста найденного текста
                    print(f"  Строка {line_num}: ...{context}...")
                # Вывод пустой строки для разделения результатов по файлам
                print()

    # Проверка, не найдено ли ни одного совпадения
    if not found_any:
        # Вывод сообщения об отсутствии совпадений
        print(f"Текст '{search_text}' не найден в указанных файлах.")


# Проверка, запущен ли скрипт напрямую (а не импортирован как модуль)
if __name__ == "__main__":
    # Вызов основной функции программы
    main()
